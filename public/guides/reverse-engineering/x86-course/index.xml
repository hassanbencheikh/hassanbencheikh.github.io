<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>0. x86 Course :: Ultimate_x64_Notes</title>
    <link>http://localhost:1313/guides/reverse-engineering/x86-course/index.html</link>
    <description>x86 Assembly Language x86 Assembly is a family of backward-compatible languages dating back to the Intel 8000 series of microprocessors. It uses mnemonics to represent CPU instructions and produces object code for x86 processors. Syntax Variants Two main syntaxes exist: AT&amp;T (source before destination) and Intel (destination before source). Intel syntax is dominant when disassembling or debugging both Windows PE and Linux ELF binaries. info A PE (Portable Executable) file is a file format used by Windows for executables (.</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 29 Aug 2025 10:50:59 -0400</lastBuildDate>
    <atom:link href="http://localhost:1313/guides/reverse-engineering/x86-course/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. Number System</title>
      <link>http://localhost:1313/guides/reverse-engineering/x86-course/number-system/index.html</link>
      <pubDate>Thu, 28 Aug 2025 19:27:31 -0400</pubDate>
      <guid>http://localhost:1313/guides/reverse-engineering/x86-course/number-system/index.html</guid>
      <description>A bit is the fundamental unit in computing, represented by an electrical state: on (1) or off (0). The binary number system uses base 2, meaning each digit’s place value is twice the value of the position to its right. Only two digits exist in binary: 0 and 1. In contrast, the decimal system is base 10, using digits 0–9; for example, decimal 15 = (1 × 10) + (5 × 1).</description>
    </item>
    <item>
      <title>2. Architecture</title>
      <link>http://localhost:1313/guides/reverse-engineering/x86-course/arch/index.html</link>
      <pubDate>Thu, 28 Aug 2025 20:32:23 -0400</pubDate>
      <guid>http://localhost:1313/guides/reverse-engineering/x86-course/arch/index.html</guid>
      <description>A computer application is a sequence of machine instructions stored in memory. The binary numbers that make up the program are meaningful only in how the CPU interprets and executes them.&#xA;Basic System Components The fundamental architecture consists of:&#xA;CPU Memory Input/output devices System bus connecting all components CPU Structure The CPU is composed of four main parts:&#xA;Control Unit&#xA;Retrieves and decodes instructions from memory Manages data transfers between CPU and memory Execution Unit</description>
    </item>
    <item>
      <title>3. General Purpose Registers</title>
      <link>http://localhost:1313/guides/reverse-engineering/x86-course/general-purpose-registers/index.html</link>
      <pubDate>Fri, 29 Aug 2025 06:46:26 -0400</pubDate>
      <guid>http://localhost:1313/guides/reverse-engineering/x86-course/general-purpose-registers/index.html</guid>
      <description>Modern processors rely on registers to temporarily store data while executing instructions. Registers are small, high-speed storage locations directly inside the CPU, much faster than accessing RAM.&#xA;In the IA-32 (x86, 32-bit) architecture, there are 8 general-purpose registers (GPRs). Although each can technically hold any type of data, many have conventional roles in programming and assembly.&#xA;note A key feature of x86 is backward compatibility: even code written for 8-bit processors decades ago can still run on modern 64-bit CPUs.</description>
    </item>
    <item>
      <title>4. Segment Registers</title>
      <link>http://localhost:1313/guides/reverse-engineering/x86-course/segment-registers/index.html</link>
      <pubDate>Fri, 29 Aug 2025 10:32:50 -0400</pubDate>
      <guid>http://localhost:1313/guides/reverse-engineering/x86-course/segment-registers/index.html</guid>
      <description>The segment registers are used for referencing memory locations in the x86 architecture.&#xA;We will focus on the flat memory model, which is the most relevant today.&#xA;Tip In the flat memory model, your program runs in a 4GB address space. Any 32-bit register can address memory within that space, except for areas reserved by the operating system.&#xA;info In 32-bit x86, registers and memory addresses are 32 bits wide.</description>
    </item>
    <item>
      <title>5. Instruction Pointer Register</title>
      <link>http://localhost:1313/guides/reverse-engineering/x86-course/instruction-pointer-register/index.html</link>
      <pubDate>Fri, 29 Aug 2025 10:50:59 -0400</pubDate>
      <guid>http://localhost:1313/guides/reverse-engineering/x86-course/instruction-pointer-register/index.html</guid>
      <description>Instruction Pointer Register (EIP) The Instruction Pointer (EIP on IA-32/x86) is one of the most important registers when working at the assembly / binary level. It holds the address of the next instruction the CPU will execute and therefore directly controls program flow.&#xA;info EIP points to the next instruction. Changing EIP changes what code the CPU executes next — this is why the register is central to control-flow, debugging, and reverse engineering.</description>
    </item>
  </channel>
</rss>